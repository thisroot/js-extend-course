# Функциональные компоненты

Рассмотрим как создавать компоненты в React не с помощью классов, а с помощью функций.

В React 0.14 был введен новый способ определения компонентов. С помощью чистых функций. Какие же плюсы есть у этого подхода и почему н устроили классы
- Функции проще, вам не нужно создавать класс, использовать `extends` и конструктор. Основная проблема была в том, что многие люди использовали классы неправильно. С чистыми функциями сложнее написать плохой код
- У вас нет необходимости использовать контект. То есть не нужно биндить `this, чтобы он был правильный и код выходит чище
- С помощью чистых функций создаются компоненты без внутреннего состояния. И у вас никогда не будет возможности выбрать хотите ли вы хранить данные в `локальном стейте` или в `нормальном сторе`. Вы просто не сможете по лени или незнанию использовать локальный стейт, а значит все ваши данные вы вынуждены будете хранить нормально.
- Описание компонентов с помощью чистых функций создает меньше кода, а значит его легче поддерживать.
- Чистые функции намного проще тестировать. Вы просто передаете `props` на вход и ожидаете какую то разметку.
- В будущем чистые функции будут выигрывать по скорости работы в сравнении с классами из-за отсутствия методов жизненного цикла

## Перепишем наше приложение

Возьмем `App.js`, который мы писали для треков и попробуем переписать на чистые функции.

- Уберем импорт компоненты из react.
```js
    import React from 'react';
```

- и заменим класс на функцию
```js
  const App = (props) =>
```
То есть сейчас у нас обычная функция `App`, которая принимает на вход `props`. Для того, чтобы не писать лишний код мы можем делать деструктуризацию сразу при прокидывании данных
```js
  const App = ({ tracks }) =>
```
- Вместо метода `render` оставим только `return` в этой функции.

```jsx
  return (
    <div>
      <Menu/>
      <div>
        <input type="text" ref={(input) => { trackInput = input }} />
        <button onClick={addTrack}>Add track</button>
      </div>
      <div>
        <input type="text" ref={(input) => { searchInput = input }} />
        <button onClick={findTrack}>Find track</button>
      </div>
      <div>
        <button onClick={onGetTracks}>Get tracks</button>
      </div>
      <ul>
        {tracks.map((track, index) =>
          <li key={index}>{track.name}</li>
        )}
      </ul>
    </div>
  );
```

- Изменим методы класса на обычные функции и уберем везде `this`. Создадим локальные переменные `trackInput` и `searchInput`. Добавим в деструктуризацию все екшены, которые мы используем

```js
  let trackInput = '';
  let searchInput = '';

  const addTrack = () => {
    console.log('addTrack', trackInput.value);
    onAddTrack(trackInput.value);
    trackInput.value = '';
  }

  const findTrack = () => {
    console.log('findTrack', searchInput.value);
    onFindTrack(searchInput.value);
  }
```

Как мы видим, после всех наших изменений код по прежнему работает. Теперь у нас вместо класса функция с параметрами, нет `this`, что упрощает работу, `connect` нам вообще не пришлось менять. Такой компонент намного проще тестировать. Нужно только помнить, что локальный стейт мы уже использовать не можем и нам нужно абсолютно все данные хранить в `store`.
